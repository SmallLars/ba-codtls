\documentclass[a4paper,10pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[babel,german=quotes]{csquotes} 
\usepackage{biblatex}

\bibliography{bibliography.bib}

% Title Page
\title{Exposé}
\author{Lars Schmertmann}

\begin{document}
\maketitle

%\begin{abstract}
%lala
%\end{abstract}

\tableofcontents
\clearpage

\chapter{Einleitung}

\section{Hintergrund/Motivation}
Während es im Internet schon seit Mitte der 90er Jahre das  "`Transport Layer Security (TLS) Protocol"' \cite{rfc5246} (früher SSL) gibt,
um den Datenverkehr über das "`Transmission Control Protocol (TCP)"' abzusichern, kam es erst 2004 zu einem ersten Versuch den Datenverkehr
über das "`User Datagram Protocol (UDP)"' zu sichern. Dieser Versuch führte 2006 schließlich zu der Standardisierung des "`Datagram Transport
Layer Security (DTLS) Protocol"' \cite{rfc6347}. Dieses ist TLS sehr ähnlich, wurde jedoch um Mechanismen ergänzt, welche in UDP im Gegensatz
zu TCP fehlen. Dazu gehört insbesondere die Transportsicherung beim Verbindungsaufbau und somit der Aushandlung der Sicherheitsmechanismen.
Diese Sicherheitsprotokolle haben sich im Internet bewährt, sind jedoch zu einer Zeit entstanden, als Sensornetze und das
"`Web of Things"' noch nicht vertreten waren. Die dort verwendeten Geräte haben nur sehr wenig Ressourcen zur Verfügung.
Dies betrifft neben wenig Rechenleistung und Speicher auch den Energievorrat. Etabliert haben sich dort das "`Constrained
Application Protocol (CoAP)"' \cite{draftcoap} über das UDP-Protokoll aufgrund ihres schlanken Designs. Passend zu UDP ist
das umfangreiche DTLS-Protokoll welches sich jedoch nicht so einfach auf "`kleinen"' Endgeräten realisieren lässt.
Genau hier soll diese Arbeit ansetzen und DTLS als Lösung bestätigen oder Alternativen aufweisen und realisieren.

\section{Verwandte Arbeiten}
Im Internet-Entwurf "`Datagram Transport Layer Security in Constrained Environments"' \cite{draftcodtls} haben K. Hartke und O. Bergmann
bereits einige Probleme aufgewiesen, die der Einsatz von DTLS in eingeschränkten Umgebungen mit sich bringt und mögliche Lösungen vorgeschlagen.

Eines der Hauptprobleme ist hier die geringe Paketgröße in 6LoWPAN-Netzen. Insbesondere beim Aufbau der sicheren Verbindung (Handshake) müssen
viele Daten ausgetauscht werden, was bei der Verwendung von DTLS die Paketgröße sprengen würde. Lösen würde das Problem bspw. eine Nutzung der
IP-Fragmentierung, was aber bei Verlust einzelner Pakete zu einem neuen Versand aller IP-Fragmente führen würde und somit hohen Traffic erzeugt,
der einen hohen Energieverbauch mit sich bringt. Ein weiterer Ansatz besteht darin, die Menge der Daten sowohl beim Verbindungsaufbau als auch
bei der Datenübertragung durch Komprimierung der Headerdaten zu verringern wofür es unterschiedliche Vorschläge gibt. Bei Nutzung von CoAP wäre
es auch möglich, den Verbindungsaufbau über CoAP zu realisieren. Dadurch ist die Transportsicherung gegeben und große Pakete könnten mit einer
blockweise Übertragung effizient übertragen werden, so dass bei Paketverlusten nur die verloren erneut übertragen werden müssten.

Beachtet werden müssen auch die Zeiten, nach denen ein Paket als verloren angesehen und erneut gesendet wird. Gerade beim Verbindungsaufbau
kann es durch aufwendige Berechnungen zu einer erhöhten Antwortzeit kommen, was nicht zu einem erneuten Paketversand führen sollte.

Beim Verbindungsaufbau werden viele Daten ausgetauscht, was gerade in eingeschränkten Umgebungen einige Zeit dauern kann. Um die Zeit
möglichst kurz zu halten, ist es wichtig die Anzahl der Kommunikationsvorgänge gering zu halten oder den Verbindungsaufbau schon durchzuführen
bevor Anwendungsdaten ausgetauscht werden, damit diese dann sofort übertragen werden können.

Um Speicher zu sparen müssen auch die Anzahl der sicheren Verbindungen begrenzt werden und/oder Verbindungen nach einiger Zeit
automatisch geschlossen werden um neue Verbindungen zu ermöglichen.


\section{Umfeld/Vorgehensweise}
Im Vordergrund soll die Implementierung eines Sicherheitsprotokolls stehen, welches sich an den Prinzipien von (D)TLS orientiert
und einige der Vorschläge aus dem Internet-Entwurf von K. Hartke und O. Bergmann, und/oder eigene Ideen, realisiert.
Die Implementierung wird im Anschluss durch einen Vergleich mit DTLS evaluiert, wobei folgende Punkte eine Rolle spielen sollen:
Volumen des generierten Traffics, Größe/Komplexität des Quellcodes und die vom Protokoll benötigte Speichermenge.

Die Implementierung besteht aus dem Clienten auf einem gängigen PC/Laptop, bei dem es keine speziellen Einschränkungen an Energie,
Speicher oder Effizienz gibt, und aus dem Server welcher für einen Redbee Econotag \cite{econotag} mit dem MC1322X
Mikrocontroller \cite{mc1322x} optimiert werden soll. Da der genannte Mikrocontroller die AES-Verschlüsselung im CTR- und CBC-Mode
in Hardware unterstützt und die Rechenleistung sowie der Speicher beschränkt ist, soll nur ein Cipher Suite "`TLS\_ECDH\_anon\_WITH\_AES\_128\_CCM"',
in Anlehnung an einen Internet-Entwurf \cite{draftaesecc}, realisiert werden. Dieses gibt einen Schlüsselaustausch mit Hilfe elliptischer
Kurven vor, welche mit kleineren Zahlen genau so sicher sind wie ein standard Diffie-Hellman-Schlüsselaustausch und sich somit effizient berechnen
lassen. Der Verschlüsselung der Anwendungsdaten erfolgt dann im "`Authenticated Encryption with Associated Data (AEAD)"' Modus \cite{rfc5116}
wobei sich hier "`Counter with CBC-MAC (CCM)"' \cite{rfc3610} aufgrund der Hardwarevorraussetzungen am besten eignet. Dieser besteht
aus einer Verschlüsselung der Daten durch AES im CTR-Modus während die dazugehörende MAC durch AES im CBC-Modus berechnet wird.
Die Anzahl der möglichen sicheren Verbindungen soll beschränkt werden, um den Speicherverbrauch gering zu halten.
Die dafür notwendigen verbindungsspezifischen Daten wie bspw. der Master-Schlüssel sollen dabei im Flash-Speicher des Redbee Econotags
abgelegt werden, so dass sie nur die für das aktuelle Paket benötigten Daten im RAM-Specher befinden. Auf diese Weise lässt sich
die Anzahl der möglichen sicheren Verbindungen trotz Beschränkung maximieren.

Bei der Evaluation soll die Datenmenge der Header-Daten sowohl beim Verbindungsaufbau als auch bei der Übertragung von Anwendungsdaten
mit einer reinen DTLS-Implementierung verglichen werden. Dabei werden nicht nur fehlerfreie Verbindungen betrachtet sondern auch Paketverluste
mit einbezogen. Verglichen wird auch der notwendige Speicherbedarf bei Verbindungsaufbau und Übertragung der Anwendungsdaten.
Ebenso soll die Größe/Komplexität des zugrunde liegenden Quellcodes bewertet werden.

\section{Ziel}
Ziel soll es sein DTLS als geeignetes Sicherheitsprotokoll auch für eingeschränkten Umgebungen zu bestätigen oder geeignete Alternativen
aufzuweisen welche nachweislich die gleichen Sicherheitsmerkmale aufweisen wie DTLS was sich über Jahre hinweg bewährt hat.

\section{Zeitplanung}
\begin{description}
  \item[31.05.2013] Fertigstellung des Exposé
  \item[07.06.2013] Fertigstellung der Infrastruktur:
    \begin{itemize}
      \item Firmware für Econotag mit Contiki \cite{contiki}, Erbium \cite{erbium} und Flashspeichermanagement aus GOBI
      \item Programm mit LibCoap \cite{libcoap} von O. Bergmann zur Kommunikation mit dem Econotag
    \end{itemize}
  \item[28.06.2013] Fertigstellung einer DTLS ähnlichen Implementierung über CoAP
  \item[05.07.2013] Fertigstellung Vergleich von DTLS und eigener Implemtierung
  \item[26.07.2013] Fertigstellung Bachelorarbeit
\end{description}

%\cite{rfc4627}
%\cite{rfc5246}
%\cite{rfc6347}
%\cite{rfc6690}
%\cite{draftcoap}
%\cite{draftcodtls}
%\cite{draftmintls}
\nocite{*}

\printbibliography

\end{document}