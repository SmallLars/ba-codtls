\documentclass[a4paper,10pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[babel,german=quotes]{csquotes} 
\usepackage{biblatex}
\usepackage{hyperref}

\bibliography{bibliography.bib}

% Title Page
\title{Exposé zur Bachelorarbeit mit dem Titel:\newline\newline Anpassungen von DTLS zur sicheren Kommunikation in eingeschränkten Umgebungen\newline\newline Adjustments of DTLS for secure communication in restricted environments}
\author{Lars Schmertmann}

\begin{document}
\maketitle

%\begin{abstract}
%lala
%\end{abstract}

\tableofcontents
\clearpage

\chapter{Einleitung}

\section{Hintergrund/Motivation}
Während es im Internet schon seit Mitte der 90er Jahre das  "`Transport Layer Security (TLS) Protocol"' \cite{rfc5246} (früher SSL) gibt,
um den Datenverkehr über das "`Transmission Control Protocol (TCP)"' abzusichern, kam es erst 2004 zu einem ersten Versuch den Datenverkehr
über das "`User Datagram Protocol (UDP)"' zu sichern. Dieser Versuch führte 2006 schließlich zu der Standardisierung des "`Datagram Transport
Layer Security (DTLS) Protocol"' \cite{rfc6347}. Dieses ist TLS sehr ähnlich, wurde jedoch um Mechanismen ergänzt, die in UDP im Gegensatz
zu TCP fehlen. Dazu gehört insbesondere die Zuverlässigkeit die beim Verbindungsaufbau und somit der Aushandlung der Sicherheitsmechanismen
notwendig ist. TLS und DTLS haben sich im Internet bewährt, sind jedoch zu einer Zeit entstanden, als Sensornetze und das
"`Web of Things"' noch nicht vertreten waren. Die dort verwendeten Geräte haben nur sehr wenig Ressourcen zur Verfügung.
Dies betrifft neben wenig Rechenleistung und Speicher auch den Energievorrat. Etabliert hat sich dort das "`Constrained
Application Protocol (CoAP)"' \cite{draftcoap} über das UDP-Protokoll aufgrund seines schlanken Designs. Passend zu UDP ist
das umfangreiche DTLS-Protokoll, das sich jedoch nicht so einfach auf "`kleinen"' Endgeräten realisieren lässt.
Genau hier soll diese Arbeit ansetzen und DTLS als Lösung bestätigen oder Alternativen aufzeigen und realisieren.

%  Ich wuerde DTLS nicht rundweg als »ersten Versuch den Datenverkehr u ̈ber das ”User Datagram Protocol (UDP)“ zu sichern.« bezeichnen.

%  Hm, worauf stuetzt sich die Aussage mit dem "ersten Versuch"? Ich
%  wuerde fast Geld darauf wetten, dass es frueher bereits Versuche 
%  dazu gab. SRTP ist z.B. auch aelter als DTLS; und das SNMP-Volk hat
%  sich auch viele kranke Dinge ausgedacht, bevor DTLS in ihr Universum 
%  aufgenommen wurde.

%  "Sind jedoch zu einer Zeit enstanden, als..." -- das trifft auf das
%  Web of Things wohl zu, auf Sensornetze sicher nicht. Die sind schon
%  ziemlich lange da (und als Begriff ein bisschen olivgruen).

\section{Verwandte Arbeiten}

\subsection{Datagram Transport Layer Security in Constrained Environments}
Im Internet-Entwurf "`Datagram Transport Layer Security in Constrained Environments"' \cite{draftcodtls} haben K. Hartke und O. Bergmann
bereits einige Probleme aufgezeigt, die der Einsatz von DTLS in eingeschränkten Umgebungen mit sich bringt und mögliche Lösungen vorgeschlagen.

Eines der Hauptprobleme ist hier die geringe Paketgröße in 6LoWPAN-Netzen, die auf 127 Byte Nutzdaten beschränkt ist. Insbesondere beim Aufbau der
sicheren Verbindung (Handshake) müssen viele Daten ausgetauscht werden, was bei der Verwendung von DTLS die Paketgröße überschreiten würde. Lösen
würde das Problem bspw. eine Nutzung der IP-Fragmentierung, was aber bei Verlust einzelner Pakete zu einem neuen Versand aller IP-Fragmente führen
würde und somit hohen Traffic erzeugt, der einen hohen Energieverbauch mit sich bringt. Ein weiterer Ansatz besteht darin, die Menge der Daten sowohl
beim Verbindungsaufbau als auch bei der Datenübertragung durch Komprimierung der Headerdaten zu verringern wofür es unterschiedliche Vorschläge gibt.
Bei Nutzung von CoAP wäre es auch möglich, den Verbindungsaufbau über CoAP zu realisieren. Dadurch ist die Transportsicherung gegeben und große Pakete
könnten mit einer blockweisen Übertragung effizient übertragen werden, so dass bei Paketverlusten nur die verlorenen Pakete erneut übertragen werden müssten.

Beachtet werden müssen auch die Zeiten, nach denen ein Paket als verloren angesehen und erneut gesendet wird. Gerade beim Verbindungsaufbau
kann es durch aufwendige Berechnungen, wie sie bspw. im Elliptic Curve Diffie-Hellman Schlüsselaustausch benötigt werden, zu einer erhöhten
Antwortzeit kommen, was nicht zu einem erneuten Paketversand führen sollte.

Beim Verbindungsaufbau werden viele Daten ausgetauscht, was gerade in eingeschränkten Umgebungen einige Zeit dauern kann. Um die Zeit
möglichst kurz zu halten, ist es wichtig die Anzahl der Kommunikationsvorgänge gering zu halten oder den Verbindungsaufbau schon durchzuführen
bevor Anwendungsdaten ausgetauscht werden, damit diese dann sofort übertragen werden können.

Um Speicher zu sparen müssen auch die Anzahl der sicheren Verbindungen begrenzt werden und/oder Verbindungen nach einiger Zeit
automatisch geschlossen werden um neue Verbindungen zu ermöglichen.

\subsection{A Hitchhiker's Guide to the (Datagram) Transport Layer Security Protocol}
Im Internet-Entwurf "`A Hitchhiker's Guide to the (Datagram) Transport Layer Security Protocol"' \cite{draftmintls} haben H. Tschofenig, S.S. Kumar
und S. Keoh zunächst die Unterschiede von TLS 1.0, 1.1 und 1.2 erläutert und klargestellt, dass die Details beim Handshake von der Wahl des Ciphersuites
abhängen. Anhand einiger Beispiele erläutern sie, dass es wichtig ist, sich der Position eines Gerätes in einer Verbindung bewusst zu sein.
So kann ein Sensor mit beschränkten Ressourcen sowohl als Server als auch als Client realisiert werden wobei es auch auf die Anzahl der möglichen
Verbindungen ankommt. Ein Sensor der als Client agiert wird mit großer Wahrscheinlichkeit immer nur einen Server kontaktieren um dort neue Sensordaten
zu hinterlegen, während ein als Server realisierter Sensor durchaus auch Anfragen von mehreren Clienten erhalten kann. Je klarer die Position und die
Umgebung des Sensors ist, desto weniger flexibel kann dieser Implementiert werden was den Aufwand und die Codegröße reduziert.

Im weiteren Verlauf gehen sie auf wichtige Design-Entscheidungen ein und Erläutern deren Bedeutung und mögliche Auswirkungen.

Kernstück des Entwurfs ist die Auswertung des Speicherverbrauchs, sowohl im ROM als auch im RAM, und die Menge der Übertragenen Daten bei einem Handshake.
Anhand eines modifizierten Prototypens zeigen sie dort auf, welche grundlegenden Teile von DTLS, ohne Berücksichtigung der Ciphersuit spezifischen Funktionen,
wieviel Speicher verbrauchen und werten die Menge der übertragenen Daten in einem kompletten Handshake für die unterschiedlichen Protokollschichten aus.
Des weiteren haben sie die Codegrößen von bspw. Hash-Funktionen und anderen für TLS notwendigen Berechnungen ausgewertet, wie sie in unterschiedlichen
Cyphersuits verwendet werden.

Abschließend stellen sie fest, dass sie TLS/DTLS durchaus auf eingeschränkte Umgebungen zuscheiden lässt, wobei mehr Flexibilität aber zu einem größeren Programmcode führt.


% \subsection{Generic Header Compression}
% todo

\section{Umfeld/Vorgehensweise}
Im Vordergrund soll die Implementierung eines Sicherheitsprotokolls stehen, das sich an den Prinzipien von DTLS orientiert
und einige der Vorschläge aus dem Internet-Entwurf von K. Hartke und O. Bergmann, und/oder eigene Ideen, realisiert.
Dabei liegt ein besonderes Interesse darauf den Handshake über CoAP zu realisieren und somit einige in DTLS eingefügte Konzepte überflüssig zu machen.
Die Implementierung wird im Anschluss durch einen Vergleich mit DTLS evaluiert, wobei folgende Punkte eine Rolle spielen sollen:
Volumen des generierten Traffics, Größe/Komplexität des Quellcodes und die vom Protokoll benötigte Speichermenge.

Die Implementierung besteht aus dem Clienten auf einem gängigen PC/Laptop, bei dem es keine speziellen Einschränkungen an Energie,
Speicher oder Effizienz gibt, und aus dem Server der für einen Redbee Econotag \cite{econotag} mit dem MC1322X
Mikrocontroller \cite{mc1322x} optimiert werden soll. Da der genannte Mikrocontroller die AES-Verschlüsselung im CTR- und CBC-Mode
in Hardware unterstützt und die Rechenleistung sowie der Speicher beschränkt ist, soll nur ein Cipher Suite "`TLS\_ECDH\_anon\_WITH\_AES\_128\_CCM\_8"',
in Anlehnung an einen Internet-Entwurf \cite{draftaesecc}, realisiert werden. Dieses gibt einen Schlüsselaustausch mit Hilfe elliptischer
Kurven vor, die mit kleineren Zahlen genau so sicher sind wie ein standard Diffie-Hellman-Schlüsselaustausch und sich somit effizient berechnen
lassen. Die Verschlüsselung der Anwendungsdaten erfolgt dann im "`Authenticated Encryption with Associated Data (AEAD)"' Modus \cite{rfc5116}
wobei sich hier "`Counter with CBC-MAC (CCM)"' \cite{rfc3610} aufgrund der Hardwarevorraussetzungen am besten eignet. Dieser besteht
aus einer Verschlüsselung der Daten durch AES im CTR-Modus während die dazugehörende MAC durch AES im CBC-Modus berechnet wird.
Die Anzahl der möglichen sicheren Verbindungen soll beschränkt werden, um den Speicherverbrauch gering zu halten.
Die dafür notwendigen verbindungsspezifischen Daten wie bspw. der Master-Schlüssel sollen dabei im Flash-Speicher des Redbee Econotags
abgelegt werden, so dass nur die für das aktuelle Paket benötigten Daten im RAM-Speicher befinden. Auf diese Weise lässt sich
die Anzahl der möglichen sicheren Verbindungen trotz Beschränkung maximieren.

Bei der Evaluation soll die Datenmenge der Header-Daten sowohl beim Verbindungsaufbau als auch bei der Übertragung von Anwendungsdaten
mit einer reinen DTLS-Implementierung verglichen werden. Dabei werden nicht nur fehlerfreie Verbindungen betrachtet sondern auch Paketverluste
mit einbezogen. Verglichen wird auch der notwendige Speicherbedarf bei Verbindungsaufbau und Übertragung der Anwendungsdaten.
Ebenso soll die Größe/Komplexität des zugrunde liegenden Quellcodes bewertet werden.

\section{Ziel}
Ziel soll es sein DTLS als geeignetes Sicherheitsprotokoll auch für eingeschränkten Umgebungen zu bestätigen oder geeignete Alternativen
aufzuzeigen die die gleichen Sicherheitsmerkmale aufweisen wie DTLS, was sich über Jahre hinweg bewährt hat.

\section{Zeitplanung}
\begin{description}
  \item[bis 31.05.2013] Fertigstellung des Exposé
  \item[bis 07.06.2013] Fertigstellung der Infrastruktur:
    \begin{itemize}
      \item Firmware für Econotag mit Contiki \cite{contiki}, Erbium \cite{erbium} und Flashspeichermanagement aus GOBI
      \item Programm mit LibCoap \cite{libcoap} von O. Bergmann zur Kommunikation mit dem Econotag
    \end{itemize}
  \item[bis 17.07.2013] Fertigstellung einer DTLS ähnlichen Implementierung über CoAP
  \item[bis 26.07.2013] Optimierung mit Headercompression
  \item[bis 09.08.2013] Evaluation der Implemtierung gegenüber DTLS
  \item[bis 23.08.2013] Fertigstellung Bachelorarbeit
\end{description}

%\cite{rfc4627}
%\cite{rfc5246}
%\cite{rfc6347}
%\cite{rfc6690}
%\cite{draftcoap}
%\cite{draftcodtls}
%\cite{draftmintls}
\nocite{*}

\printbibliography

\end{document}