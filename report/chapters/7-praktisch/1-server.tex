\section{Server}

Der Server wird auf einem Redbee Econotag \cite{econotag} realisiert. Der darauf enthaltene Mikrocontroller \glos{mc1322} \cite{mc1322} enthält,
neben dem IEEE 802.15.4 Funkstandard und einer \acr{aes} Hardware-Engine, 128 KiB Flash-Speicher und 96 KiB RAM-Speicher. Bei Inbetriebnahme
wird das im Flash-Speicher vorliegende Programm vollständig in den RAM-Speicher kopiert und dort ausgeführt, wodurch sich eine maximale
Programmgröße von 96 KiB ergibt. Die zusätzlichen 32 KiB Flash-Speicher können somit für die Ablage von Daten genutzt werden, die auch nach einer
Stromunterbrechung, oder einem Neustart des Geräts, erhalten bleiben sollen. Zu berücksichtigen ist jedoch auch noch, dass der letzte 4 KiB große
Block schon für den Redbee Econotag selbst reserviert ist.

Betrieben wird der Server mit SmartAppContiki \cite{erbium}, das auf Contiki \cite{contiki} basiert, und eine Implementierung von \acr{coap}, in
der Entwurfsversion 13 \cite{draftcoap13}, enthält. In der Standardkonfiguration benötigt SmartAppContiki, mit einer definierten \acr{coap}-Ressource,
die ein "`Hallo Welt!"' zurückgibt, \textasciitilde 84 KiB. Diese Daten teilen sich gemäß Abbildung \ref{tbl:contiki-speicher} auf. Um den benötigten
Speicher zu optimieren wurde die Größe des "`Sys Stack"' und des "`Heap"' in der Konfigurationsdatei "`contiki/cpu/mc1322x/mc1322x.lds"' angepasst.

\begin{figure}[!ht]
\centering
\begin{tabular}{l|r|r}
  \hiderowcolors
  \textbf{Beschreibung} & \textbf{Standard} & \textbf{Angepasst}\\
  \hline
  Programm        & ~~~~~59248 Byte    & ~~~~~59248 Byte\\
  Irq Stack       &   256 Byte         &   256 Byte\\
  Fiq Stack       &   256 Byte         &   256 Byte\\
  Svc Stack       &   256 Byte         &   256 Byte\\
  Abt Stack       &    16 Byte         &    16 Byte\\
  Und Stack       &    16 Byte         &    16 Byte\\
  Sys Stack       &  1024 Byte         &  2048 Byte\\
  Datensegment    & 20872 Byte         & 20872 Byte\\
  Heap            &  4096 Byte         &    16 Byte\\
  \hline
  \textbf{Gesamt} & 86040 Byte         & 82984 Byte\\
                  & $ \approx $ 84 KiB & $ \approx $ 81 KiB\\
  \showrowcolors
\end{tabular}
\caption{Speicheraufteilung von SmartAppContiki}
\label{tbl:contiki-speicher}
\end{figure}

Das wurde möglich durch Verwendung der in Contiki eingebauten Beobachtungswerkzeuge. Durch Definieren von periodischen Ausgaben der benutzen Heap
sowie Sys Stack Größe, in "`contiki/platform/redbee-econotag/contiki-mc1322x-main.c"', können die Auslastungen beobachtet werden. Um diesen Prozess
effizienter zu gestalten, wird nur die Initialisierung durchgeführt und die periodischen Ausgaben deaktiviert. In "`server/server.c"' lässt sich nun,
durch Aktivieren des Debug-Modus, ein Code einbinden, der auf Knopfdruck sowohl die Speicheraufteilung als auch die bisher genutzten Bytes des Sys Stack
und Heap ausgibt. Dadurch lässt sich erkennen, dass der Heap garnicht benutzt wird, und somit unnötig Speicher belegt. Da insbesondere während des Handshakes,
unter anderem aufgrund der Berechnung von elliptischen Kurven, viele Daten zwischengespeichert werden müssen, wird ersichtlich, dass ein Sys Stack von 1024
Byte nicht ausreicht, eine Größe von 2048 Byte jedoch optimal ist. Durch diese Anpassungen wurde der, für SmartAppContiki benötigte, Speicher von \textasciitilde
84 KiB auf \textasciitilde 81 KiB reduziert (siehe Abbildung \ref{tbl:contiki-speicher}). Somit stehen für die Umsetzung von \acr{dtls} \textasciitilde 15 KiB zur
Verfügung, wobei auch berücksichtig werden muss, dass noch die Funktionen des Geräts selbst implementiert werden müssen.

Bei der Benutzung der, in SmartAppContiki enthaltenen, \acr{coap} 13 Implementierung, hat sich herausgestellt, dass die Unterstützung für die \acr{coap}-Option
"`Block 1"' fehlt. Diese Option wird von einem Clienten benutzt, um größere Datenmengen, in einer \acr{coap}-Anfrage, in Blöcke zu unterteilen, damit es nicht
zu einer Fragmentierung auf IP-Ebene kommt. Da diese Funktion für den \acr{dtls}-Handshake notwendig ist, wurde sie für Datenmengen bis 128 Byte nachgerüstet,
wobei dieser Wert in der Datei "`contiki/apps/er-coap-13/er-coap-13.h"' durch Änderung von "`COAP\_BLOCK1\_BUFFER\_SIZE"' eingestellt werden kann. Übertragen
werden mit Hilfe der Option ein ClientHello oder ClientKeyExchange + ChangeCipherSpec + Finished, wobei die Länge von letzterem mit insgesamt 112 Byte
(87 + 3 + 22), durch die einzig definierte Ciphersuit, fest ist. Anders ist dies bei dem ClientHello, welches durch eine Vielzahl, vom Client beherrschter
Ciphersuits, sehr viel größer als 128 Byte werden kann. Hier erfolgt dann jedoch eine \acr{coap}-Fehlermeldung "`5.01 NOT IMPLEMENTED"' mit einem
Hinweis auf die begrenzte Maximalgröße, so dass ein Client sein Angebot an Ciphersuits reduzieren kann, um der maximalen Größe gerecht zu werden.

Während bisher jede \acr{coap}-Anfrage in der \acr{coap} 13 Implementierung zu einem Aufruf des entsprechenden Ressource-Handlers geführt hat, verhält sich
dies bei einer \acr{coap}-Anfrage mit der Block 1-Option anders. Hier werden die Daten zunächst in einem Buffer gesammelt und ein Aufruf des Ressource-Handlers
vermieden, wobei der Empfang jedes Blocks bestätigt wird. Erst bei Eintreffen des letzten Blocks, wenn die Anfrage vollständig ist, wird der Ressource-Handler
aufgerufen, um die Anfrage zu bearbeiten und eine Antwort zu generieren. Um an die Daten der Anfrage zu gelangen, dient die Methode "`coap\_get\_payload"'.
Diese wurde so angepasst, dass sie bei einer Anfrage ohne Block 1-Option wie gewohnt auf die Daten des aktuellen Pakets zeigt, bei einer Anfrage mit Block 1-Option
jedoch auf den Buffer zeigt. In diesem Moment wird der Buffer als gelesen markiert, so dass ein erneuter Aufruf von "`coap\_get\_payload"' wieder auf die Daten
des aktuellen Pakets zeigt.

Während bisher allgemeine Anpassungen von SmartAppContiki bzw. dem darin enthaltenen \acr{coap} 13 beschrieben wurden, folgt in den nächsten 3 Abschnitten
die Erläuterung von 3 implementierten Contiki-Apps, welche für die Realisierung von \acr{dtls} notwendig sind. Die Implementierung von \acr{dtls} wird dann
im 4. Abschnitt erläutert, wonach abschließend noch eine Update-Funktion erläutert wird, die für \acr{dtls} nicht notwendig ist, aber dessen Umfeld berücksichtigt.

\subsection{Contiki-App: "`flash-store"'}

Für eine Nutzung des erweiterten Flash-Speichers wird die App "`flash-store"' verwendet. Als Basis für die Implementierung dient Code aus dem Bachelor-Projekt
GOBI. Dieser war jedoch noch nicht als Contiki-App organisiert sondern direkt mit in den Code eingebunden. Auch ist die Aufteilung der 4 KiB großen
Flash-Speicher-Blöcke eine andere. Diese Aufteilung ist in Abbildung \ref{tbl:2-1_2-persistent} zu sehen. Während oben die 8 Speicherblöcke mit ihren Adressen
aufgeführt sind, werden darunter die Aufteilungen für unterschiedliche Zwecke angegeben, wobei dort sowohl die GOBI-Aufteilung als auch die neue
Aufteilung aufgeführt sind.

\begin{figure}[!ht]
\centering
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{|p{1.4cm}|p{1.4cm}|p{1.4cm}|p{1.4cm}|p{1.4cm}|p{1.4cm}|p{1.4cm}|p{1.4cm}|}
  \hiderowcolors
  \hline
  $ 0x18000\newline -\newline 0x18 $FFF & $0x19000\newline -\newline 0x19 $FFF & $ 0x1 $A$ 000\newline -\newline 0x1 $AFFF & $ 0x1 $B$ 000\newline -\newline 0x1 $BFFF & $ 0x1 $C$ 000\newline -\newline 0x1 $CFFF & $ 0x1 $D$ 000\newline -\newline 0x1 $DFFF & $ 0x1 $E$ 000\newline -\newline 0x1 $EFFF & $ 0x1 $F$ 000\newline -\newline 0x1 $FFFF\\
  \hline
  \multicolumn{8}{l}{~}\\
  \multicolumn{8}{l}{Aufteilung innerhalb des Bachelor-Projekts GOBI:}\\
  \hline
  RO 1 & \multicolumn{2}{l|}{RW 1} & \multicolumn{2}{l|}{RW 2} & \multicolumn{2}{l|}{RO 2} & SR\\
  \hline
  \multicolumn{1}{c|}{~} & \multicolumn{2}{c|}{$ 0x0000 - 0x0 $FFF} & \multicolumn{2}{c|}{$ 0x1000 - 0x1 $FFF} & \multicolumn{3}{c}{$ \leftarrow $ virtuelle Speicheradressen} \\
  \cline{2-5}
  \multicolumn{8}{l}{~}\\
  \multicolumn{8}{l}{Neue Aufteilung für \acr{dtls}:}\\
  \hline
  \multicolumn{2}{|l|}{RW 1} & \multicolumn{2}{l|}{RW 2} & RAD & \multicolumn{2}{l|}{RO} & SR\\
  \hline
  \multicolumn{2}{|c|}{$ 0x0000 - 0x0 $FFF} & \multicolumn{2}{c|}{$ 0x1000 - 0x1 $FFF} & \multicolumn{1}{c}{~} & \multicolumn{3}{c}{$ \leftarrow $ virtuelle Speicheradressen} \\
  \cline{1-4}
  \multicolumn{8}{l}{~}\\
  \multicolumn{8}{l}{Legende: RW = Read-Write, RAD = Read-Append-Delet, RO = Read-Only, SR = System-Reserved}\\
  \showrowcolors
\end{tabular}
\renewcommand{\arraystretch}{1.0}
\caption{Aufteilung des erweiterten Flash-Speichers}
\label{tbl:2-1_2-persistent}
\end{figure}

Geändert wurde zunächst die Position der beiden RW-Blöcke. Diese ermöglichen das Schreiben von Daten, ohne die Eigenschaften des Flash-Speichers berücksichtigen
zu müssen. Dieser kann nur beschrieben werden, falls die betroffene Position vorher einmal gelöscht wurde, was sich aber nur in Blöcken a 4 KiB realisieren lässt.
Um Datenverluste zu vermeiden, werden jeweils zwei 4 KiB große Blöcke benutzt, um einen 4 KiB großen Speicher zu realisieren, der sich durch virtuelle Adressen
ansprechen lässt, welche ebenfalls in Abbildung \ref{tbl:2-1_2-persistent} aufgeführt sind. Die Daten sind immer nur in einem Block gespeichert, während der andere
Block gelöscht ist. Kommt es zu einem Schreibvorgang, wird der Datenblock in den leeren Block kopiert, wobei die gewünschten Änderungen realisiert werden.
Die Position der beiden RW-Blöcke befindet sich nun am Anfang, da sich so die Adressen, der jeweils zusammengehörenden Blöcke, genau um 1 Bit unterscheiden.
Das vereinfacht die Berechnung der Quell- und Ziel-Adresse erheblich, so dass durch Optimierung des Quellcodes 70 Byte an Programmgröße eingespart werden.

Problemtisch ist jedoch die Dauer und der Energieverbrauch bei einem Schreibzugriff dieser Art. Um eine effizientere Ablage von Daten zu ermöglichen folgt
nach den beiden RW-Blöcken anstatt des RO-Blocks nun ein RAD-Block. Dieser ist vergleichbar mit einem Stack ohne Push- und Pop-Funktion. Für die Initialisierung
wird der komplette Block gelöscht. Daten können nun so lange eingefügt werden, bis der Block voll ist. Wieviel Daten gerade enthalten sind, wird dabei in einer
globalen Variablen im RAM-Speicher gespeichert. Der Lesezugriff kann dabei beliebig erfolgen.

Gleich geblieben ist die Position des RO-Blocks. Dort können im Vorfeld, durch das bereits erwähnte Programm "`Blaster"', Daten abgelegt werden, welche zur Laufzeit
ausgelesen werden können. Dies spart Programmgröße, da diese "`Konstanten"' nicht im Datensegment des Programms enthalten sind.

Abschließend folgt noch ein Block der für den Redbee Econotag selbst reserviert ist, und somit nicht genutzt werden kann.

\subsection{Contiki-App: "`time"'}

Im Gegensatz zu herkömmlichen Desktop-Rechnern oder Servern verfügt der Redbee Econotag über keine innere Uhr bezüglich der Realzeit.
Angeboten wird vom \glos{mc1322} lediglich das Register "`MACA\_CLK"' welches mit einem Takt von 250 KHz erhöht wird. Um damit eine
32 bit Unixzeit zu generieren, .. \TODO{weitermachen ..., reicht für 4,77 Stunden}

Alternative: CRM\_RTC\_COUNT / CRM\_RTC\_TIMEOUT = Sekunden ... reicht für ca 60 Stunden, je nach Wert der Kalibrierung

nicht so toll, reicht für die testzwecke

problematisch bei stromverlust / betteriewechsel

per interrupt korrekturen wegen überlauf

im gobi master projekt werden eh timer zwecks schlafmodus untersucht


\subsection{Contiki-App: "`ecc"'}
jens und jens-quellen erwähnen\\
assembler code erwähnen der in zusammenarbeit mit jens enstanden ist\\
3 mothoden und varianten kurz erläuterm\\
neugierig machen auf mehr -> .asm -> carry besser nutzen

\subsection{Contiki-App: "`er-13-dtls"'}
es kann nur ein handshake zur zeit stattfinden\\
psk wird nur benötigt bis pre master secret berechnet\\
am ende des handshakes wird alter psk vernichtet und neuer generiert\\
kann durch uri /psk über sichere leitung abgerufen werden so dass weitere handshakes durchgeführt werden können

für hello verify cookie: cmac(client-ip + clienthello)

verschlüsselung von finish mit seq\_num 0. erste app daten beginnen also bei seq\_num 1.\\
seq\_num wird im ram gehalten da bei flash update bei jedem paket hoher verschleiß.\\
sollte seq\_num je 0 sein, wird sie mit der seq\_num der anfrage "`wiederhergestellt"' (erläuterung: ist nicht exakt)

\subsection{Update-Funktion}
flasher beschreiben: überschreibt den programmcode jedoch nicht die vom blaster generierten gerätedaten