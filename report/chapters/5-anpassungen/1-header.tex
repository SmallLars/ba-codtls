\section{Header}

Da die maximale Datenmenge in \acr{6lowpan}-Paketen auf 127 Byte begrenzt ist würde der in DTLS definierte Header mit 13 Byte schon mehr als 10\% des
Datenvolumens ausmachen. Um das zu vermeiden wird die Stateless Header Compression aus dem Entwurf von K. Hartke und O. Bergmann \cite{draftcodtls}
angewendet. Diese zeichnet sich durch eine verlustfreie Komprimierung aus, für die keine weiteren Informationen bereitgestellt werden müssen. Damit
lässt sich der Header im besten Fall auf 2 Byte, wie in Abbildung \ref{fig:com_handshake_header} dargestellt, komprimieren.

\begin{figure}[ht]
  \centering
  \begin{lstlisting}[language=c]
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |0| T | V |  E  |1 1 0|  S  | L |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  \end{lstlisting}
  \caption{Komprimierter Handshake-Header}
  \label{fig:com_handshake_header}
\end{figure}

Der RecordType (T) kann mit 2 Bit folgende 4 Zustände annehmen: \textit{type\_8\_bit} (0), \textit{alert} (1), \textit{dtls\_data} (2) und \textit{application\_data} (3).
Diese weichen von dem oben genannten Entwurf und \acr{dtls} ab, da der Handshake über \acr{coap} realisiert wird. Somit ist es erforderlich, zwischen
Anwendungsdaten, \acr{dtls}-Daten, welche in \acr{coap}-Paketen transportiert werden, und Daten des Alert-Protokolls zu unterscheiden. \acr{dtls}-Daten sind die
Daten die während eines Handshakes ausgetauscht werden womit dort auch das ChangeChiperSpec-Protokoll enthalten ist. Das Alert-Protokoll ist nach wie vor separat,
da hier eine zuverlässige Datenübertragung nicht erforderlich ist und \acr{coap} somit nicht benutzt wird. Sollten weitere RecordTypes erforderlich sein, ist es möglich
T auf 0 zu setzten und einen 8 Bit langen RecordType an den Header anzuhängen.

Die Codierung der Version (V) wurde ohne Änderungen übernommen und kann mit 2 Bit folgende 4 Zustände annehmen: \textit{dtls\_1\_0} (0), \textit{version\_16\_bit} (1),
\textit{dtls\_1\_2} (2) und \textit{version\_future\_use} (3). \acr{dtls} 1.0 und \acr{dtls} 1.2 können hier direkt definiert werden, da \acr{dtls} 1.0 weit verbreitet
 und \acr{dtls} 1.2 die aktuellste Version ist. Auf \acr{dtls} 1.1 wurde verzichtet, da Implementierungen die über \acr{dtls} 1.0 hinaus gehen im Allgemeinen auch
\acr{dtls} 1.2 unterstützen. Auch hier ist es möglich weitere Versionen an den Header anzuhängen, in dem V auf 1 gesetzt wird wobei hier mit 2 Byte das in \acr{tls}
definierte Versionsformat zum Einsatz kommt.

Auch die Epoche (E) wurde ohne Änderungen übernommen. Mit den Werten 0 bis 4 kann diese direkt angegeben werden. Da jede Kommunikation mit der Epoche 0 beginnt, und
nach dem ersten Handshake in Epoche 1 fortgeführt wird, sind dies die am Häufigsten verwendeten Werte. Jeder weitere Handshake erhöht die Epoche um 1, so dass auch
weitere Epochen möglich sind ohne den Header zu vergrößern. Sollten höhere Werte benötigt werden, lässt sich das mit den folgenden Zuständen realisieren:
\textit{epoch\_8\_bit} (5), \textit{epoch\_16\_bit} (6) und \textit{epoch\_implicit} (7). So können 8 oder 16 Bit lange Epochen an den Header gehängt werden, was den
durch \acr{dtls} vorgebenen Bereich vollständig abdeckt. Alternativ kann durch \textit{epoch\_implicit} signalisiert werden, dass es sich bei der Epoche um die gleiche
handelt, wie bei dem vorausgehenden \acr{dtls}-Paket innerhalb des gleichen \acr{udp}-Pakets.

Für die Sequenz-Nummer (S) sind mit 3 Bit 8 Zustände möglich. Während mit den Werten 1 bi 6 die Länge in Byte der angehängten Sequenz-Nummer angegeben wird,
kann durch den Wert 0 die Angabe unterbunden werden. Im Allgemeinen wird die Sequenz-Nummer in Verbindung mit der Epoche zur Berechnung des \acr{mac}s herangezogen.
Jedoch gibt es \glospl{ciphersuit} die andere Mechanismen verwenden, so dass keine Sequenz-Nummer notwendig ist. Falls mehrere \acr{dtls}-Pakete innerhalb eines
\acr{udp}-Pakets enthalten sind, kann die Sequenz-Nummer durch den Wert 7 auch relativ zum Vorgänger-Paket (+1) angegeben werden.

Schließlich folgt noch ein 2 Bit Wert für die Länge. Falls im \acr{udp}-Paket nur ein \acr{dtls}-Paket enthalten ist, kann hier der Wert 0 gesetzt werden, wodurch
keine Länge angegeben wird. Diese ist durch die Länge des \acr{udp}-Pakets implizit bekannt. Mit den Werten 1 und 2 kann die Länge in Byte der angehängten Länge
angegeben werden, während durch den Wert 3 das letzte \acr{dtls}-Paket im \acr{udp}-Paket gekennzeichnet wird, dessen Länge wieder implizit bekannt ist.