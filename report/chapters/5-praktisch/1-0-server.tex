\section{Server}
\label{sec:server}

Der Server wird auf einem Redbee Econotag \cite{econotag} realisiert. Der darauf enthaltene Mikrocontroller \glos{mc1322} \cite{mc1322} enthält,
neben dem IEEE 802.15.4 Funkstandard und einer \acr{aes} Hardware-Engine, 128 KiB Flash-Speicher und 96 KiB RAM-Speicher. Bei Inbetriebnahme
wird das im Flash-Speicher vorliegende Programm vollständig in den RAM-Speicher kopiert und dort ausgeführt, wodurch sich eine maximale
Programmgröße von 96 KiB ergibt. Die zusätzlichen 32 KiB Flash-Speicher können somit für die Ablage von Daten genutzt werden, die auch nach einer
Stromunterbrechung, oder einem Neustart des Geräts, erhalten bleiben sollen. Zu berücksichtigen ist jedoch auch noch, dass der letzte 4 KiB große
Block schon für den Redbee Econotag selbst reserviert ist.

Betrieben wird der Server mit SmartAppContiki \cite{erbium}, das auf Contiki \cite{contiki} basiert, und eine Implementierung von \acr{coap}, in
der Entwurfsversion 13 \cite{draftcoap13}, enthält. In der Standardkonfiguration benötigt SmartAppContiki, mit einer definierten \acr{coap}-Ressource,
die ein "`Hallo Welt!"' zurückgibt, 83,73 KiB. Diese Daten teilen sich gemäß Abbildung \ref{tbl:contiki-speicher} auf. Um den benötigten
Speicher zu optimieren wurde die Größe des "`Sys Stack"' und des "`Heap"' in der Konfigurationsdatei "`contiki/cpu/mc1322x/mc1322x.lds"' angepasst.
Außerdem wurde "`REST\_MAX\_CHUNK\_SIZE"' in der Contiki-App "`Erbium"' von 128 auf 48 Byte reduziert, wodurch das Datensegment weniger Speicher benötigt.
Diese Konstante definiert die maximale Größe der Anwendungsdaten, die in einem Contiki-Paket untergebracht werden können, und stellt somit sicher,
dass jedes \acr{coap}-Paket in ein einzelnes IP-Paket passt.

\begin{figure}[!ht]
\centering
\begin{tabular}{l|r|r}
  \hiderowcolors
  \textbf{Beschreibung} & \textbf{Standard} & \textbf{Angepasst}\\
  \hline
  Programm        & ~~~~~58760 Byte    & ~~~~~58760 Byte\\
  Irq Stack       &   256 Byte         &   256 Byte\\
  Fiq Stack       &   256 Byte         &   256 Byte\\
  Svc Stack       &   256 Byte         &   256 Byte\\
  Abt Stack       &    16 Byte         &    16 Byte\\
  Und Stack       &    16 Byte         &    16 Byte\\
  Sys Stack       &  1024 Byte         &  2048 Byte\\
  Datensegment    & 21064 Byte         & 20744 Byte\\
  Heap            &  4096 Byte         &    16 Byte\\
  \hline
  \textbf{Gesamt} & 85744 Byte         & 82368 Byte\\
                  & 83,73 KiB          & 80,44 KiB\\
  \showrowcolors
\end{tabular}
\caption{Speicheraufteilung von SmartAppContiki}
\label{tbl:contiki-speicher}
\end{figure}

Das wurde möglich durch Verwendung der in Contiki eingebauten Beobachtungswerkzeuge. Durch Definieren von periodischen Ausgaben der benutzen Heap
sowie Sys Stack Größe, in "`contiki/platform/redbee-econotag/contiki-mc1322x-main.c"', können die Auslastungen beobachtet werden. Um diesen Prozess
effizienter zu gestalten, wird nur die Initialisierung durchgeführt und die periodischen Ausgaben deaktiviert. In "`server/server.c"' lässt sich nun,
durch Aktivieren des Debug-Modus, ein Code einbinden, der auf Knopfdruck sowohl die Speicheraufteilung als auch die bisher genutzten Bytes des Sys Stack
und Heap ausgibt. Dadurch lässt sich erkennen, dass der Heap garnicht benutzt wird, und somit unnötig Speicher belegt. Da insbesondere während des \glospl{handshake},
unter anderem aufgrund der Berechnung von elliptischen Kurven, viele Daten zwischengespeichert werden müssen, wird ersichtlich, dass ein Sys Stack von 1024
Byte nicht ausreicht, eine Größe von 2048 Byte jedoch optimal ist. Durch diese Anpassungen wurde der, für SmartAppContiki benötigte, Speicher von 83,73 KiB
auf 80,44 KiB reduziert (siehe Abbildung \ref{tbl:contiki-speicher}). Somit stehen für die Umsetzung von \acr{dtls} \textasciitilde 15,5 KiB zur
Verfügung, wobei auch berücksichtig werden muss, dass noch die Funktionen des Geräts selbst implementiert werden müssen.

Bei der Benutzung der, in SmartAppContiki enthaltenen, \acr{coap} 13 Implementierung, hat sich herausgestellt, dass die Unterstützung für die \acr{coap}-Option
Block-1 fehlt. Diese Option kann von einem Clienten benutzt werden, um größere Datenmengen, in einer \acr{coap}-Anfrage, in Blöcke zu unterteilen, damit es nicht
zu einer Fragmentierung auf IP-Ebene kommt. Laut Aussage von Matthias Kovatsch wird "`auf die atomare Variante aus Platzgründen verzichtet, da man Block1 ganz
einfach im Resource-Handler lösen kann"`. Da diese Option für den \acr{dtls}-\glos{handshake} generell benötigt wird, und ohne Code-Duplizierung auch anderen Ressourcen
zur Verfügung stehen soll, wird sie in ähnlicher Form wie die Separate-Option implementiert. Das Separate-Modul bietet Methoden an, um den Client, während der
Bearbeitung einer Anfrage, zu informieren, dass die Bearbeitung einige Zeit dauert, und die Beantwortung der Anfrage später fortzusetzen. In diesem Sinne bietet
das Block-1-Modul eine Methode an, mit der die Parameter der Block-1-Option überprüft und bearbeitet werden, wobei bei Bedarf die entsprechenden Fehler generiert
werden, oder die erhaltenen Daten auf Wunsch zusammengesetzt werden. Genau wie das Separate-Modul kann das Block1-Modul optional in einer Ressource benutzt werden.
Dabei ist nach wie vor ein Empfang von Daten ohne Block-1-Option möglich. Durch den Rückgabewert der Methode, lässt sich in der Ressource entscheiden, ob schon
die einzelnen Datenblöcke bearbeitet werden, oder erst die vollständige Nachricht, nach Erhalt aller Blöcke. Damit das Separate-Modul auch in Kombination mit dem
Block-1-Modul genutzt werden kann, wurde das Separate-Modul entsprechend angepasst um die Block-1-Option zu berücksichtigen.

Während bisher allgemeine Anpassungen von SmartAppContiki bzw. dem darin enthaltenen \acr{coap} 13 beschrieben wurden, folgt in den nächsten vier Abschnitten
die Erläuterung von vier implementierten Contiki-Apps, welche für die Realisierung von \acr{dtls} benutzt werden. Die Implementierung von \acr{dtls} wird dann
im 5. Abschnitt erläutert, wonach abschließend noch eine Update-Funktion erläutert wird, die für \acr{dtls} nicht notwendig ist, aber dessen Umfeld berücksichtigt.

\input{chapters/5-praktisch/1-1-flash.tex}
\input{chapters/5-praktisch/1-2-time.tex}
\input{chapters/5-praktisch/1-3-aes.tex}
\input{chapters/5-praktisch/1-4-ecc.tex}
\input{chapters/5-praktisch/1-5-dtls.tex}
\input{chapters/5-praktisch/1-6-update.tex}