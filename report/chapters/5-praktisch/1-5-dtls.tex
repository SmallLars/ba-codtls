\subsection{Contiki-App: "`er-13-dtls"'}

Um diese Contiki-App zu realisieren, sind zunächst einige Anpassungen in er-coap-13 notwendig. Um nach wie vor einen Betrieb ohne \acr{dtls} realsisieren zu können,
werden diese Anpassungen nur dann aktiv, wenn die Compiler-Anweisung WITH\_DTLS gesetzt ist, was im Makefile für ein Contiki-Programm durch "`CFLAGS += -DWITH\_DTLS=1"'
realisiert werden kann. Bei der Verwendung von \acr{dtls} wird der Port gemäß \cite[Seite 93]{portnumbers} von 5683 auf 5684 geändert. Außerdem wird der Datenverkehr
über \acr{dtls}-Funktionen geleitet, die den Record-Layer realisieren und die Daten bei Bedarf ent- oder verschlüsseln. Kernstück ist die Ressource "`/dtls"', die für
die Durchführung des Handshakes in CoAP eingebunden wird.

Für die Realisierung des Recory-Layers und der \acr{dtls}-Ressource sind einige Module notwendig, die im Folgenden zunächst beschrieben werden.

\begin{description}
  \item[er-dtls-13-alert.{$[$h|c$]$}] Stellt zwei Funktionen für den Versand einer Alert-Nachricht zur Verfügung.
					Während die eine, ohne Verwendung con CoAP, eine Nachricht an den Kommunikationspartner sendet,
					konfiguriert die andere eine CoAP-Antwort. Dieser Unterschied ist notwendig, da einige Fehler während
					des Handshakes auftauchen, und per CoAP kommentiert werden, damit es nicht zu einer neuen Anfrage kommt.
					Würden diese Nachrichten direkt mit dem Record-Protokoll versand, müsste sich der Empfänger darum kümmern,
					die Anfrage aus dem CoAP-Layer zu entfernen.
  \item[er-dtls-13-data.{$[$h|c$]$}] Erstellt und verwaltet sessionspezifische Daten. Die Anzahl der Sessions ist hier auf maximal zehn begrenzt.
					Damit die dafür notwendigen 1400 Byte nicht dauerhaft den RAM-Speicher belegen, sind diese im Flash-Speicher
					abgelegt. Die Ausnahme bilden hier die beiden Werte für die Sequenznummern zum Lesen und Schreiben.
					Während letztere bei jedem Datenaustausch geändert werden, werden die grundlegenden Session-Daten nur während
					des Handshakes geschrieben, so dass hier die Nutzung des Flash-Speichers sinnvoll ist. Dafür wird der RW-Block
					verwendet, der durch die Contiki-App flash-store zur Verfügung gestellt wird. Die Sessions sind dort in einem
					Array hinterlegt, wobei die genutzten Stellen entsprechend gekennzeichnet sind. Dadurch werden bei der Suche
					nach Sessions unter Umständen auch leere Stellen durchlaufen, jedoch bleibt der Aufwand erspart die Liste zu
					defragmentieren oder Zeiger einer verketteten Liste zu aktualisieren. Da pro Session zwei Keyblöcke benötigt werden,
					falls es zu einem erneuten Handshake kommt, sind diese in einem separaten Array mit der Länge 20 hinterlegt.
					Der Index der Keyblöcke ergibt sich dabei aus dem Index der Session. Liegt diese im ersten Array an Index $ i $,
					Sind die dazu gehörenden Keyblöcke an Index $ i\cdot2 $ und $ i\cdot2+1 $ hinterlegt. Dabei liegt der derzeit gültige
					Keyblock immer an Index $ i\cdot2 $. Bei einer Weiterentwicklung der Epoche, wird der 2. Keyblock an den Index
					des ersten kopiert. Da die Sequenznummern im RAM-Speicher abgelegt sind, gehen diese bei einem Batteriewechsel,
					oder Neustart des Endgeräts, verloren, womit die Session nicht fortgesetzt werden kann. Da es keine sinnvolle Lösung gibt,
					diese ohne Sicherheitslücken wiederherzustellen, wird bei einem Start des Endgeräts der RW-Block des Flash-Speichers
					zurückgesetzt, wodurch alle Sessiondaten gelöscht werden. Bei einer folgenden Anfrage wird der Client zunächst eine
					Alert-Nachricht bekommen, was aber dann zu einem neuen Handshake führt.
  \item[er-dtls-13-prf.{$[$h|c$]$}] Enthält die im \glos{ciphersuite} definierte \acr{prf}. Die größte Datenmenge wird für die Berechnung des Master-Secrets
					benötigt. Dort gehen 153 Byte in die Berechnung ein. Dieses ist ausreichend klein um die Berechnung mit einem
					Funktionsaufruf durchzuführen, womit der Programmcode klein gehalten wird, da kein Zustand für eine Fortsetzung
					der Berechnung gespeichert und genutzt werden muss.
  \item[er-dtls-13-psk.{$[$h|c$]$}] Verwaltet den \acr{psk} und generiert bei Bedarf einen neuen. Der \acr{psk} wird im Vorfeld durch das Programm Blaster
					generiert und im Flash-Speicher abgelegt. Soll ein neuer \acr{psk} generiert werden, um den Werks-\acr{psk} zu deaktivieren,
					wird ein Byte im RW-Block des Flash-Speichers gesetzt und dort ebenfalls ein neuer \acr{psk} hinterelgt. Wird der \acr{psk}
					abgerufen, kann anhand des gesetzten Bytes erkannt werden, ob der Werks-\acr{psk} gilt oder ein neuer Verfügbar ist.
					Kommt es zu einem Batteriewechsel oder Neustart des Endgeräts, ist der Werks-\acr{psk} wieder gültigt, da der RW-Block
					zurückgesetzt wurde.
  \item[er-dtls-13-random.{$[$h|c$]$}] Bietet Funktionen für die Generierung von Zufallszahlen an. Dieses Modul benutzt das MACA\_RANDOM Register des \glos{mc1322},
					das durch Contiki bereits initialisiert wurde. Durch Auslesen des Registers können beliebig viele Zufallswerte erzeugt werden.
\end{description}

Im Record-Layer wird das Modul für die Sessionverwaltung und das Modul für die Alert-Nachrichten genutzt. Bei der Bearbeitung einer Nachricht, werden die benötigten
Session-Daten abgerufen und zur Bearbeitung der Nachricht genutzt. Sollten dabei Fehler auftreten, wird eine Alert-Nachricht an den Client gesendet und das Paket verworfen.
Zu beachten ist bei eingehenden Daten, dass sowohl Handshake-Nachrichten als auch Anwendungsdaten \acr{coap}-Pakete enthalten. Während Handshake-Nachrichten in
Epoche 0, ohne Verschlüsselung, gestattet sind, ist dies bei Anwendungsdaten nicht erlaubt. Bei Handshake-Nachrichten wird somit sichergestellt, dass die erste,
im \acr{coap}-Paket enthaltene, \acr{uri} "`dtls"' entspricht, da ein Angreifer ansonsten beliebige \acr{coap}-Anfragen als Handshake-Nachricht tarnen könnte.

In der \acr{coap}-Ressource "`/dtls"' werden schließlich Handshake-Nachrichten bearbeitet. Falls es hier zu Fehlern kommt wird der Client darüber in einer
\acr{coap}-Antwort, die durch das Modul für die Alert-Nachrichten generiert wird, informiert. Ein Fehler resultiert in einem Abbruch des Ressource-Handlers,
was durch einen Sprung an das Ende der Methode realisiert wird, damit globale Variablen zurückgesetzt werden können.

Um Speicher zu sparen, und die Block-1-Option von \acr{coap} einfach nutzen zu können, wird nur ein Handshake zur Zeit gestattet. Dafür wird bei einem Aufruf des
Ressource-Handlers, anhand einer globalen Variable, überprüft, ob die Ressource gerade in Benutzung ist. Ist dies der Fall, wird die Absender-IP verglichen.
Stimmt diese mit der Absender-IP der letzten Anfrage überein, kann die Anfrage trotzdem bearbeitet werden. Bei Bearbeitung der Anfrage, wird die Ressource
zunächst generell gesperrt. Ist eine Block-1-Übertragung abgeschlossen, wird die Ressource generell wieder freigegeben. Nur die Bearbeitung einer
ClientHello-Nachricht mit korrektem Cookie führt im weiteren Verlauf zu einer erneuten Sperrung, da hier ein Zustand erzeugt wird, der erst in der darauffolgenden
Anfrage abgearbeitet wird.  \TODO{probleme, angriffe, reaktionen, timeout}

psk wird nur benötigt bis pre master secret berechnet\\
am ende des handshakes wird alter psk vernichtet und neuer generiert\\
kann durch uri /psk über sichere leitung abgerufen werden so dass weitere handshakes durchgeführt werden können

für hello verify cookie: cmac(client-ip + clienthello)

verschlüsselung von finish mit seq\_num 0. erste app daten beginnen also bei seq\_num 1.\\
seq\_num wird im ram gehalten da bei flash update bei jedem paket hoher verschleiß.\\

uri syntax \cite{rfc3986}. beachten wegen session-id

Übertragen werden mit Hilfe der Option ein ClientHello oder ClientKeyExchange + ChangeCipherSpec + Finished, wobei die Länge von Letzterem mit
insgesamt 114 (87 + 3 + 22) Byte, durch die einzig definierte \glos{ciphersuite}, fest ist. Anders ist dies bei dem ClientHello, welches durch
eine Vielzahl, vom Client beherrschter \glospl{ciphersuite}, sehr viel größer werden kann.

Hier erfolgt dann jedoch eine \acr{coap}-Fehlermeldung "`4.13 REQUEST ENTITY TOO LARGE"' mit einem Hinweis auf die begrenzte Maximalgröße,
so dass ein Client sein Angebot an \glospl{ciphersuite} reduzieren kann, um der maximalen Größe gerecht zu werden.

auswertung cookie -> query. cookie in packet ist doof

problem: handshake: uri prüfen !