\subsection{Contiki-App: "`ecc"'}

Für die Berechnung von elliptischen Kurven wurde im Bachelor-Projekt GOBI von Jens Trillmann ein C-Programm implementiert.
Dieses basiert auf einer Implementierung für einen 8-bit Mikrocontroller \cite{eccori}, wurde jedoch für 32-bit-Prozessoren optimiert.
Getestet und benutzt wird diese Implementierung bisher nur auf Desktop-Rechnern, wobei hier die Ausführung der Berechnungen in nicht
wahrnehmbarer Zeit erledigt wird.

Um die Berechnungen auch auf dem Redbee Econotag durchzuführen, wird die Implementierung in eine eigene Contiki-App übernommen.
Da der \glos{mc1322}-Mikrocontroller ebenfalls 32-bit-Berechnungen durchführt, ist dies zunächst direkt möglich. Im Gegensatz
zu Prozessoren in Desktop-Systemen arbeitet der Mikrocontroller jedoch mit einer wesentlich geringen Taktfrequenz, so dass sich
die benötigte Rechenzeit für eine Multiplikation auf elliptischen Kurven auf 13 Sekunden beläuft. In Zusammenarbeit mit Jens
Trillmann sind deshalb zunächst die drei Grundfunktionen "`Addition"', "`Subtraktion"' und "`Right-Shift"' für große Zahlen in
Assembler realisiert worden, um die Berechnung schneller zu machen. Weitere Optimierungen sollen in der Bachelorarbeit von Jens
Trillmann folgen.

Auf Basis des "`ARM GCC Inline Assembler Cookbook"' \cite{armasm} sind für die drei Grundfunktionen einige Varianten entstanden.
Welche davon jeweils genutzt wird, lässt sich in den einzelnen Quellcode-Dateien einstellen. Generell bietet sich eine Umsetzung
in Assembler an, da sich das sogenannte "`Carry-Bit"' nutzen lässt. In diesem wird bei einer Rechenoperation ein möglicher Überlauf
gespeichert. Für die gängigen Rechenoperationen gibt es zwei unterschiedliche Befehle, wobei nur bei einem das Carry-Bit genutzt wird.
Dieses Potenzial zu nutzen, hat sich jedoch als schwierig herausgestellt, da Contiki das Thumb-Instruktion-Set des \glos{mc1322} nutzt.
Im Gegensatz zum ARM-Instruktion-Set, dass 32-bit-Operationen nutzt, sind es im Thumb-Instruktion-Set nur 16 Bit. Jede Thumb-Instruktion
wird bei Ausführung automatisch in die entsprechende ARM-Instruktion umgewandelt und ausgeführt. Durch die begrenzte Größe stehen jedoch
nicht alle ARM-Instruktionen zur Verfügung und die Anzahl der nutzbaren Register ist auf 8 reduziert. Der Vorteil liegt jedoch in der
geringen Programmgröße, so dass Contiki überhaupt erst auf dem \glos{mc1322} betrieben werden kann.

Alle drei Grundfunktionen sind zunächst ohne Einschränkung, der auch in C implementierten Funktionalität, umgesetzt. Insbesondere sind somit
die Längen der Ein- und Ausgabewerte variabel, was sich nur mit einer Schleife realisieren lässt. Eine Schleife bedeutet jedoch auch, dass
ein Zähler erhöht und verglichen werden muss. Da der Block mit dem Carry-Bit im Thumb-Instruktion-Set durch alle Operationen aktualisiert wird,
geht das Carry-Bit der Hauptoperation vom einen zum nächsten Schleifendurchlauf verloren, muss manuell zwischengespeichert, und bei Bedarf
berücksichtigt werden. Ein Sichern und Wiederherstellen des Blocks mit dem Carry-Bit ist nur im ARM-Instruktion-Set möglich.
Die Optimierung besteht bei dieser Umsetzung somit nur darin, dass es einfach möglich ist, einen Überlauf zu erkennen.
Während dies bei der Addition und Subtraktion 24 und 32 Byte Programmgröße einspart, bringt es bei Right-Shift
keinen Größenvorteil. Jedoch ist die Berechnung aufgrund der eingesparten Vergleiche bei allen Operationen schneller.

Da im Thumb-Instruktion-Set für einen Right-Shift keine Funktion zur Verfügung steht, die das Carry-Bit direkt benutzt, ist hier keine weitere Optimierung möglich.
Für die Addition und Subtraktion sind weitere Varianten verfügbar. Da die Subtraktion ausschließlich für die Berechnung von 256-bit-Zahlen benutzt wird,
was acht 32-bit-Blöcken entspricht, ist es möglich, die acht Subtraktionen direkt hintereinander auszuführen, so dass das Carry-Bit ohne weitere
Eingriffe direkt berücksichtigt wird. Die Programmgröße nimmt dabei, im Vergleich zum C-Code, um \textasciitilde 32 Byte ab und die
Berechnungsgeschwindigkeit nimmt wesentlich zu. Anders verhält es sich bei der Addition, da Werte unterschiedlicher Größe addiert werden.
Notwendig sind hier 32, 64, 128, 256 und 512 Bit. Für jede dieser Größen ist nun ein eigener Additionsblock vorhanden. Bei Aufruf der Funktion wird
die Größe überprüft und der richtige Block ausgewählt. Dies bietet eine maximale Geschwindigkeit, erhöht jedoch die Größe des Programms um 116 Byte.

Um weitere 96 Byte einzusparen, sind 3 benötigte Konstanten im Flash-Speicher hinterlegt. Dazu gehören die X- und Y- Koordinate des Basis-Punkts, der für
den Diffie-Hellman-Schlüsselaustausch verwendet wird, und die Ordnung der verwendeten elliptischen Kurve. Die Ordnung wird nur verwendet, um zu überprüfen,
ob der zufällig generierte private Schlüssel sich für die Benutzung eignet. Bei Bedarf werden die Werte aus dem Flash-Speicher geladen und nur so lange
im Stack abgelegt, wie sie benötigt werden.

Weitere Optimierungen bezüglich der Programmgröße und Berechnungsgeschwindigkeit sollen in der Bachelorarbeit von Jens Trillmann folgen.