\subsection{Contiki-App: "`aes"'}

Um die \acr{aes}-Funktionen des \glos{mc1322} \cite{mc1322} zu nutzen, dient diese Contiki-App. Die bereits beschriebene \glos{ciphersuite}
verwendet in der \acr{prf} \acr{aes}-\acr{cmac} \cite{rfc4493}. Außerdem wird für die Verschlüsselung \acr{aes}-\acr{ccm} \cite{rfc3610} verwendet. Beide Verfahren
werden vom \glos{mc1322} nicht direkt unterstützt. Bereitgestellt wird nur der reine \acr{aes}-Verschlüsselungsprozess im \acr{ctr}- und \acr{cbc}-Mode.

Damit die \acr{aes}-Hardware genutzt werden kann, muss diese zunächst initialisiert werden. Die dafür notwendige Methode wurde zum Großteil aus dem Bachelorprojekt \glos{gobi}
übernommen und leicht modifiziert. Neben der Aktivierung der \acr{aes}-Hardware wir dort ein Selbsttest mit einem internen Schlüssel durchgeführt. Ist dieser
erfolgreich, werden die beiden Modi \acr{ctr} und \acr{cbc}, für die spätere Nutzung, aktiviert.

Die \acr{aes}-Berechnungen selbst werden durch Übertragen der notwendigen Daten in Register des Mikrocontrollers durchgeführt. Diese sind auf Speicheradressen
abgebildet, die wiederum in Konstanten in der Bibliothek des Mikrocontrollers hinterlegt sind. Da es sich um eine 128-bit-Verschlüsselung handelt, der Mikrocontroller
aber nur in 32 Bit arbeitet, sind für jeden Wert vier Register notwendig. Diese sind jeweils von 0 bis 3 durchnummeriert, was in der folgenden Beschreibung durch <X>
dargestellt wird. Zusätzlich sind zwei Register notwendig, um den Verschlüsselungsprozess zu starten und auswerten zu können.

\begin{description}
  \item[KEY<X>] Schlüssel zur Ver- und Entschlüsselung. Verbleibt so lange im Register, bis das \acr{aes}-Modul zurückgesetzt, oder das Register überschrieben wird.
  \item[DATA<X>] Datenpaket mit Klar- oder Geheimtext.
  \item[CTR<X>] Zähler für den \acr{ctr}-Mode. Dieser wird nicht automatisch erhöht und muss somit vor jeder Berechnung gesetzt werden.
  \item[CTR<X>\_RESULT] Ergebnis der \acr{ctr}-Berechnung. Dafür wurde der hinterlegte Zähler verschlüsselt und durch die XOR-Funktion mit dem Datenpaket verknüpft. Dieses Register kann nur gelesen werden.
  \item[CBC<X>\_RESULT] Ergebnis der \acr{cbc}-Berechnung. Dafür wurde das Datenpaket durch die XOR-Funktion mit dem Ergebnis der letzten Verschlüsselung verknüpft und dann verschlüsselt. Dieses Register kann nur gelesen werden.
  \item[MAC<X>] Kann mit einem Initialisierungsvector belegt werden, der für die \acr{cbc}-Berechnung herangezogen wird.
  \item[CONTROL$0$bits] Enthät u. a. ein Bit, durch das die Verwendung des Initilalisierungsvectors gekennzeichnet wird. Außerdem ist ein Bit dafür vorgesehen, den Ver- und Entschlüsselungsprozess zu starten.
  \item[STATUSbits]  Enthät u. a. ein Bit, das kennzeichnet, ob die aktuelle Berechnung abgeschlossen ist.
\end{description}

Da der Ent- und Verschlüsselungsprozess derselbe ist, reicht eine Methode für die Umsetzung von \acr{aes}-\acr{ccm} aus. Diese arbeitet in-place, was bedeutet,
dass die Daten direkt an ihrer Position im Speicher konvertiert werden, und zusätzlich nur eine konstante, von der Datenmenge unabhängige, Menge Speicher benötigt
wird. Während für die Verschlüsselung ein Aufruf der Methode ausreicht, da die Daten verschlüsselt werden, und der \acr{mac} berechnet wird, sind für die Entschlüsselung
zwei Aufrufe notwendig. Zunächst werden die Daten entschlüsselt, wobei automatisch ein neuer \acr{mac}, auf Basis des Geheimtextes, generiert wird. Dieser hat jedoch
keinen Nutzen. Im 2. Schritt wird die Funktion erneut aufgerufen, um ausschließlich den \acr{mac} zu generieren, damit dieser mit dem erhaltenen verglichen werden kann.
Das führt im 1. Schritt zwar zu unnötigen Berechnungen, verlangsamt aber den Prozess nicht, da Entschlüsselung und \acr{mac}-Berechnung parallel in der Hardware
durchgeführt werden. Der Vorteil liegt hier in der geringen Programmgröße.

Die Methode zur Berechnung der \acr{cmac} ist so gestaltet, dass die Berechnung in mehreren Schritten erfolgen kann, solange die Länge der übergebenen Daten ein
Vielfaches von 16 Byte (128 Bit) beträgt. Erst durch Setzen des letzten Parameters, welcher den Abschluss signalisiert, ist die Datenlänge beliebig, und die
Berechnung wird gemäß \acr{cmac}-Vorgabe abgeschlossen.