\subsection{Contiki-App: "`flash-store"'}

Für eine Nutzung des erweiterten Flash-Speichers wird die App "`flash-store"' verwendet. Als Basis für die Implementierung dient Code aus dem Bachelorprojekt
\glos{gobi}. Dieser war jedoch noch nicht als Contiki-App organisiert, sondern direkt mit in den Code eingebunden. Auch ist die Aufteilung der 4 KiB großen
Flash-Speicher-Blöcke eine Andere. Diese Aufteilung ist in Abbildung \ref{tbl:2-1_2-persistent} zu sehen. Während oben die 8 Speicherblöcke mit ihren Adressen
aufgeführt sind, werden darunter die Aufteilungen für unterschiedliche Zwecke angegeben, wobei dort sowohl die \glos{gobi}-Aufteilung als auch die neue
Aufteilung aufgeführt sind.

\begin{figure}[!ht]
\centering
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{|p{1.4cm}|p{1.4cm}|p{1.4cm}|p{1.4cm}|p{1.4cm}|p{1.4cm}|p{1.4cm}|p{1.4cm}|}
  \hiderowcolors
  \hline
  $ 0x18000\newline -\newline 0x18 $FFF & $0x19000\newline -\newline 0x19 $FFF & $ 0x1 $A$ 000\newline -\newline 0x1 $AFFF & $ 0x1 $B$ 000\newline -\newline 0x1 $BFFF & $ 0x1 $C$ 000\newline -\newline 0x1 $CFFF & $ 0x1 $D$ 000\newline -\newline 0x1 $DFFF & $ 0x1 $E$ 000\newline -\newline 0x1 $EFFF & $ 0x1 $F$ 000\newline -\newline 0x1 $FFFF\\
  \hline
  \multicolumn{8}{l}{~}\\
  \multicolumn{8}{l}{Aufteilung innerhalb des Bachelorprojekts \glos{gobi}:}\\
  \hline
  RO 1 & \multicolumn{2}{l|}{RW 1} & \multicolumn{2}{l|}{RW 2} & \multicolumn{2}{l|}{RO 2} & SR\\
  \hline
  \multicolumn{1}{c|}{~} & \multicolumn{2}{c|}{$ 0x0000 - 0x0 $FFF} & \multicolumn{2}{c|}{$ 0x1000 - 0x1 $FFF} & \multicolumn{3}{c}{$ \leftarrow $ virtuelle Speicheradressen} \\
  \cline{2-5}
  \multicolumn{8}{l}{~}\\
  \multicolumn{8}{l}{Neue Aufteilung für \acr{dtls}:}\\
  \hline
  \multicolumn{2}{|l|}{RW 1} & \multicolumn{2}{l|}{RW 2} & RAD & \multicolumn{2}{l|}{RO} & SR\\
  \hline
  \multicolumn{2}{|c|}{$ 0x0000 - 0x0 $FFF} & \multicolumn{2}{c|}{$ 0x1000 - 0x1 $FFF} & \multicolumn{1}{c}{~} & \multicolumn{3}{c}{$ \leftarrow $ virtuelle Speicheradressen} \\
  \cline{1-4}
  \multicolumn{8}{l}{~}\\
  \multicolumn{8}{l}{Legende: RW = Read-Write, RAD = Read-Append-Delet, RO = Read-Only, SR = System-Reserved}\\
  \showrowcolors
\end{tabular}
\renewcommand{\arraystretch}{1.0}
\caption{Aufteilung des erweiterten Flash-Speichers}
\label{tbl:2-1_2-persistent}
\end{figure}

Geändert wurde zunächst die Position der beiden RW-Blöcke. Diese ermöglichen das Schreiben von Daten, ohne die Eigenschaften des Flash-Speichers berücksichtigen
zu müssen. Dieser kann nur beschrieben werden, falls die betroffene Position vorher einmal gelöscht wurde, was sich aber nur in Blöcken a 4 KiB realisieren lässt.
Um Datenverluste zu vermeiden, werden jeweils zwei 4 KiB große Blöcke benutzt, um einen 4 KiB großen Speicher zu realisieren, der sich durch virtuelle Adressen
ansprechen lässt, welche ebenfalls in Abbildung \ref{tbl:2-1_2-persistent} aufgeführt sind. Die Daten sind immer nur in einem Block gespeichert, während der andere
Block gelöscht ist. Kommt es zu einem Schreibvorgang, wird der Datenblock in den leeren Block kopiert, wobei die gewünschten Änderungen realisiert werden.
Die Position der beiden RW-Blöcke befindet sich nun am Anfang, da sich so die Adressen, der jeweils zusammengehörenden Blöcke, genau um ein Bit unterscheiden.
Das vereinfacht die Berechnung der Quell- und Ziel-Adresse erheblich, so dass durch Optimierung des Quellcodes 70 Byte an Programmgröße eingespart werden.

Problemtisch ist jedoch die Dauer und der Energieverbrauch bei einem Schreibzugriff dieser Art. Um eine effizientere Ablage von Daten zu ermöglichen folgt
nach den beiden RW-Blöcken anstatt des RO-Blocks nun ein RAD-Block. Dieser ist vergleichbar mit einem Stack ohne Push- und Pop-Funktion. Für die Initialisierung
wird der komplette Block gelöscht. Daten können nun so lange eingefügt werden, bis der Block voll ist. Wieviel Daten gerade enthalten sind, wird dabei in einer
globalen Variablen im RAM-Speicher gespeichert. Der Lesezugriff kann dabei beliebig erfolgen.

Gleich geblieben ist die Position des RO-Blocks. Dort können im Vorfeld, durch das bereits erwähnte Programm "`Blaster"', Daten abgelegt werden, welche zur Laufzeit
ausgelesen werden können. Dies spart Programmgröße, da diese "`Konstanten"' nicht im Datensegment des Programms enthalten sind.

Abschließend folgt noch ein Block der für den Redbee Econotag selbst reserviert ist, und somit nicht genutzt werden kann.