\chapter{TLS / DTLS}

Das Sicherheitsprotokoll \acr{tls} wird im Allgemeinen mit dem stromorientierten \acr{tcp} verwendet.
Wurde durch \acr{tcp} eine Verbindung hergestellt, können Daten von beliebieger Größer in jede Richtung
übertragen werden. \acr{tcp} wird dafür sorgen, dass der eingegebene Bytestrom vollständig und in der
richtigen Reihenfolge auf der Gegenseite wieder ausgegeben wird. Um die \acr{tls} bezogenen Daten nun
zu kennzeichnen und voneinander abzugrenzen existiert der "`Record Layer"' wie in Abbildung \ref{fig:recordlayer}
dargestellt. Dort ist neben der Art des Inhalts und der Protokollversion auch die Länge enthalten, so dass
aufeinanderfolgende Pakete im Datenstrom voneinander abgegrenzt werden können. Als Inhalt kommen 4 Protokolle
in Frage. Währen das Application-Data-Protokoll für den Transport der Anwendungsdaten genutzt wird, kommt
das Handshake-Protokoll für die Aushandlung der Sicherheitsparameter zum Einsatz. Über das Change-Cipher-Spec-Protokoll
werden die zuletzt ausgehandelten Sicherheitsparameter aktiviert. Sollte es beim Handshake oder der Übertragung
von Anwendungsdaten zu Fehlern kommen, werden diese mit Hilfe des Altert-Protokolls übertragen.

Da bei \acr{dtls} im Allgemeinen das paketorientierte \acr{udp} verwendet wird, bei dem die Länge eines
Paketinhalts bekannt ist, wirkt die Längenangabe zunächst überflüssig. Jedoch ist es insbesondere bei einem
\glos{handshake} sinnvoll, mehrere \acr{dtls}-Pakete innerhalb eines \acr{udp}-Pakets zusammenzufassen,
so dass auch hier wieder eine Längenangabe benötigt wird, um die Pakete voneinander abzugrenzen.
Zusätzlich sind bei \acr{dtls} nun die Datenfelder für die Epoche und die Sequenznummer hinzugekommen.
Wärend diese beiden Werte bei \acr{tls} durch die gewährleistete Reihenfolge der Daten durch \acr{tcp}
implizit bekannt sind, müssen diese bei \acr{dtls} explizit angegben werden, da \acr{udp} weder die
Reihenfolge noch den Transport der Daten garantiert. Die Epoche wird bei einem erfolgreichen \glos{handshake}
erhöht und ordnet so die dazugehörenden Daten den im \glos{handshake} ausgehandelten Sicherheitsparametern zu,
während die Sequenznummer in jeder Epoche bei 0 beginnt und bei jedem Paketversand erhöht wird.

\begin{figure}[ht]
  \centering
  \begin{lstlisting}[language=c]
  struct {
    ContentType type;
    ProtocolVersion version;
    uint16 epoch;                           // Nur bei DTLS
    uint48 sequence_number;                 // Nur bei DTLS
    uint16 length;
    uint8  fragment[DTLS_Record.length];
  } DTLS_Record;
  \end{lstlisting}
  \caption{Record Layer von TLS / DTLS}
  \label{fig:recordlayer}
\end{figure}

\section{Handshake}

Damit es überhaupt zu einer sicheren Verbindung kommen kann, müssen zunächst einige Sicherheitsparameter mit Hilfe des Handshake-Protokolls ausgehandelt werden.
Ein Handshake Paket setzt sich gemäß Abbildung \ref{fig:handshakelayer} zusammen. Während es bei TLS ausreichend ist, den Typ, die Länge und die Daten selbst
zu senden, wurden bei DTLS weitere Datenfelder ergänzt. Das message\_seq dient zur Durchnummerierung der Handshake-Nachrichten um Paketverluste von UDP zu erkennen
und eine mögliche falsche Reihenfolge der Pakete auszugleichen. Da UDP eine begrenzte Paketgröße hat und eine Fragmentierung der UDP-Pakete auf IP-Ebene
vermieden werden soll, müssen Handshakenachrichten eventuell auf mehrere UDP-Pakete verteilt werden. Um dies zu ermöglichen wurden fragment\_offset und fragment\_length
ergänzt. So können die Daten in mehrere Teile geteilt werden während die Länge und die Position im Paket hinterlegt werden. length enthält nach wie vor die
Gesamtlänge, so dass eine Fragmentierung jederzeit erkannt werden kann.

\begin{figure}[ht]
  \centering
  \begin{lstlisting}[language=c]
  struct {
    HandshakeType msg_type;
    uint24 length;
    uint16 message_seq;                     // Nur bei DTLS
    uint24 fragment_offset;                 // Nur bei DTLS
    uint24 fragment_length;                 // Nur bei DTLS
    uint8  fragment[Handshake.length];
  } Handshake;
  \end{lstlisting}
  \caption{Handshake Protokoll von TLS / DTLS}
  \label{fig:handshakelayer}
\end{figure}

Der bei einem Handshake entstehende Nachrichtenaustausch in vollständiger Form ist in Abbildung \ref{fig:handshake} aufgeführt.

\begin{figure}[ht]
  \centering
  \begin{lstlisting}[language=c]
                      Client           Server
                      ------           ------

         ClientHello (seq=0) -------->

                             <-------- HelloVerifyRequest  (seq=0)    // Nur bei DTLS

         ClientHello (seq=1) -------->                                // Nur bei DTLS
         (with cookie)                                                // Nur bei DTLS

                             <--------        ServerHello  (seq=1)
                             <--------        Certificate* (seq=2)
                             <--------  ServerKeyExchange  (seq=3)
                             <-------- CertificateRequest* (seq=4)
                             <--------    ServerHelloDone  (seq=5)

        Certificate* (seq=2) -------->
  ClientKeyExchange  (seq=3) -------->
  CertificateVerify* (seq=4) -------->
   ChangeCipherSpec          -------->
           Finished  (seq=5) -------->

                             <--------    ChangeCipherSpec
                             <--------            Finished (seq=6)

   Application Data          <------->    Application Data
  \end{lstlisting}
  \caption{Nachrichtenaustausch während eines TLS / DTLS Handshakes}
  \label{fig:handshake}
\end{figure}

Eingeleitet wird dieser mit einem ClientHello, in dem der Client seine Möglichkeiten bekannt gibt. Dazu gehören u.a. die unterstützten Protkollversionen, Ciphersuits
und Kompressionsmethoden. Während der Server bei TSL nun direkt mit einem ServerHello und weiteren Handshake-Paketen antworten kann, lässt sich das bei DTLS so nicht
realisieren. Da UDP kein verbindungsorientiertes Protkoll ist, können Pakete mit gefälschtem Absender versendet werden. Auf diese Art könnte ein \acr{dos} Angriff
durchgeführt werden, in dem zahllose Pakete mit unterschiedlichen Absendern an den Server gesendet werden, welche alle ein ClientHello enthalten. Problematisch ist
hierbei der Zustand der für jedes ClientHello im Server erzeugt wird. Neben dem Speicherverbrauch kann die Berechnung des ServerKeyExchange eine Menge Rechenleistung
benötigen, so dass die Ressourcen des Servers schnell aufgebraucht sind. Um dies zu vermeiden und den Absender zu verifizieren wurde in DTLS ein Cookie ergänzt.
Dieser wird aus dem ClientHello generiert und als Antwort an den Clienten gesendet. So kann der Server den Cookie bei einem erneuten ClientHello wieder berechnen
und mit dem mitgelieferten vergleichen. So bei der ersten Anfrage ein Zustand vermieden und der Client verifiziert.


% TODO change-cipher-spec ist keine handshake nachricht um "`abrisse in der pipeline"' zu verhindern. -> bei erhalt und versand werden die read/write epoch geändert.
% bei allen anderen bleiben diese konstant